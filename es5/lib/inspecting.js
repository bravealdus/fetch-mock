'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var FetchMock = {};

FetchMock.callsFilteredByName = function (name) {
	if (name === true) {
		return this._allCalls.filter(function (call) {
			return !call.unmatched;
		});
	}
	if (name === false) {
		return this._allCalls.filter(function (call) {
			return call.unmatched;
		});
	}

	if (typeof name === 'undefined') {
		return this._allCalls;
	}

	if (this._calls[name]) {
		return this._calls[name];
	}
	return this._allCalls.filter(function (_ref) {
		var _ref2 = _slicedToArray(_ref, 1),
		    url = _ref2[0];

		return url === name || url.url === name;
	});
};

FetchMock.calls = function (name) {
	var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	if (typeof options === 'string') {
		options = { method: options };
	}

	var calls = this.callsFilteredByName(name);

	if (options.method) {
		var testMethod = options.method.toLowerCase();
		calls = calls.filter(function (_ref3) {
			var _ref4 = _slicedToArray(_ref3, 2),
			    url = _ref4[0],
			    _ref4$ = _ref4[1],
			    opts = _ref4$ === undefined ? {} : _ref4$;

			var method = (url.method || opts.method || 'get').toLowerCase();
			return method === testMethod;
		});
	}
	return calls;
};

FetchMock.lastCall = function (name, options) {
	return [].concat(_toConsumableArray(this.calls(name, options))).pop();
};

FetchMock.normalizeLastCall = function (name, options) {
	var call = this.lastCall(name, options) || [];
	if (this.config.Request.prototype.isPrototypeOf(call[0])) {
		return [call[0].url, call[0]];
	}
	return call;
};

FetchMock.lastUrl = function (name, options) {
	return this.normalizeLastCall(name, options)[0];
};

FetchMock.lastOptions = function (name, options) {
	return this.normalizeLastCall(name, options)[1];
};

FetchMock.called = function (name, options) {
	return !!this.calls(name, options).length;
};

FetchMock.flush = function () {
	return Promise.all(this._holdingPromises);
};

FetchMock.done = function (name) {
	var _this = this;

	var names = name && typeof name !== 'boolean' ? [name] : this.routes.map(function (r) {
		return r.name;
	});

	// Can't use array.every because
	// a) not widely supported
	// b) would exit after first failure, which would break the logging
	return names.map(function (name) {
		if (!_this.called(name)) {
			console.warn('Warning: ' + name + ' not called'); // eslint-disable-line
			return false;
		}
		// would use array.find... but again not so widely supported
		var expectedTimes = (_this.routes.filter(function (r) {
			return r.name === name;
		}) || [{}])[0].repeat;

		if (!expectedTimes) {
			return true;
		}

		var actualTimes = _this.calls(name).length;
		if (expectedTimes > actualTimes) {
			console.warn('Warning: ' + name + ' only called ' + actualTimes + ' times, but ' + expectedTimes + ' expected'); // eslint-disable-line
			return false;
		} else {
			return true;
		}
	}).filter(function (bool) {
		return !bool;
	}).length === 0;
};

module.exports = FetchMock;